# 核心标签

Marko 内置了一些标签。

## 控制流

### `<if>`, `<else-if>`, `<else>`

 `<if>`、`<else-if>`和`<else>` 标签为模板提供了条件控制流。

```marko
<if(arriving)>
    <div>Hey there</div>
</if>
<else-if(leaving)>
    <div>Bye now</div>
</else-if>
<else>
    <div>What's up?</div>
</else>
```

条件也可以作为属性来使用：

```marko
<div if(arriving)>Hey there</div>
<div else-if(leaving)>Bye now</div>
<div else>What's up?</div>
```

同时也支持复杂表达式：

```marko
<if(Math.random() > 0.5)>
    <div>50-50 chance of seeing this</div>
</if>
```

### `<for>`

`<for>` 标签能用来迭代一个数组中的元素：

```marko
<ul>
    <for(color in colors)>
        <li>${color}</li>
    </for>
</ul>
```

它也可以作为一个属性被使用：

```marko
<ul>
    <li for(color in colors)>${color}</li>
</ul>
```

使用上述任意一种模板，以及下面`colors`值：

```js
var colors = ['red', 'green', 'blue'];
```

输出HTML都将如下所示：

```html
<ul>
    <li>red</li>
    <li>green</li>
    <li>blue</li>
</ul>
```

#### 循环状态变量（Loop Status Variable）

`for`指令也支持循环状态变量，因为你可能需要知道当前的循环索引，例如：

```marko
<ul>
    <li for(color in colors | status-var=loop)>
        ${color}
        ${loop.getIndex()+1}) of ${loop.getLength()}
        <if(loop.isFirst())> - FIRST</if>
        <if(loop.isLast())> - LAST</if>
    </li>
</ul>
```

##### 循环状态方法（Loop Status Methods）

###### `getLength()`

返回数组的长度

###### `getIndex()`

返回当前循环的索引

###### `isFirst()`

如果当前索引是第一个索引，则返回“`true”`，否则返回`false`

###### `isLast()`

如果当前索引是最后一个索引，则返回“`true”`，否则返回`false`

#### 循环分隔符（Loop eparator）

循环分隔符被用于通过字符来分隔循环中的值。分隔符不会给第一个元素加上前缀，同时也不会给最后一个元素加上后缀：

```marko
<div>
    <!-- Output: red, green, blue -->
    <span for(color in colors | separator=", ") style="color: ${color}">
        ${color}
    </span>
</div>
```

#### 局部循环
#### Range Looping

可以用系列的格式为循环提供范围：`<var-name> from <from> to <to>[ step <step>]`.

`from`，`to`和`step`的值必须是数值表达式。如果未指定`step`，则`step`默认为1。

```marko
<ul>
    <li for(i from 0 to 10)>
        ${i}
    </li>
</ul>
```

```marko
<ul>
    <li for(i from 0 to 10 step 2)>
        ${i}
    </li>
</ul>
```

```marko
<ul>
    <li for(i from 0 to myArray.length-1)>
        ${myArray[i]}
    </li>
</ul>
```

#### 属性循环

```marko
<ul>
    <li for(name, value in settings)>
        <b>${name}</b>: ${value}
    </li>
</ul>
```

#### 原生JavaScript循环

```marko
<for(var i=1; i<=3; i++)>
    ${i}
</for>
```

#### 自定义迭代器


```marko
static function reverseIterator(arrayList, callback) {
    for(var i=arrayList.length-1; i>=0; i--){
        callback(arrayList[i]);
    }
}

<div for(item in ['a', 'b', 'c'] | iterator=reverseIterator)>
    ${item}
</div>
```

输出如下:

```html
<div>c</div>
<div>b</div>
<div>a</div>
```

### `<while>`

通过使用`while`指令，任何元素可以在满足条件的条件下重复。`while`指令可以应用为元素或者属性。
Any element can be repeated until a condition is met by using the `while` directive. The directive can be applied as an element or as an attribute.

_应用为属性:_

```marko
$ var n = 0;

<ul>
    <li while(n < 4)>
        ${n++}
    </li>
</ul>
```

_应用为元素:_

```marko
$ var n = 0;

<ul>
    <while(n < 4)>
        <li>${n++}</li>
    </while>
</ul>
```

### `body-only-if`

如果，你需要条件渲染一个用作包装容器的元素，但是，被其包装的内容主体（body）总是被渲染的，那么你可以使用`body-only-if`属性来处理这个用例。例如，当存在一个有效的URL时，才渲染一个`<a>`包装标签，那么你可以执行以下操作：

```marko
<a href=input.linkUrl body-only-if(!input.linkUrl)>
    Some body content
</a>
```

当`input.linkUrl`的值为`"http://localhost/"`时，输出结果如下：

```marko
<a href="http://localhost/">
    Some body content
</a>
```

当`input.linkUrl`的值为`undefined`时，输出结果如下：

```marko
Some body content
```

## JavaScript

以下标签始终在采用[concise syntax](./concise.md)时使用，即使在使用生成HTML输出的标签的HTML语法时也是如此。
The following tags are always written using the [concise syntax](./concise.md), even when using HTML syntax for tags that generate HTML output.

### `import`
> **Static:** **当import被加载时，由`import`生成的代码将会运行一次，并被所有调用进行共享。它必须被声明为顶层标签，并且无法访问`data`，`state`或者在render中传递的其他值。

`import`标签用于从外部文件访问数据和方法。它遵循与[JavaScript `import` statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import)相同的语法。

```marko
import sum from './utils/sum';
<div>The sum of 2 + 3 is ${sum(2, 3)}</div>
```

<!-- ### `<export>`
> **Static:** 

The code generated by `export` will run once when the template is loaded and be shared by all calls to render. It must be declared as a top level tag and does not have access to `data`, `state`, or other values passed in at render.

The `export` tag is used to export values from the template.  It follows the same syntax as the [JavaScript `export` statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export), but only named exports are supported (the default export is the template).

```marko
export var route = '/about';

<!doctype html>
<html>
    <body>
        <h1>About us</h1>
    </body>
</html>
``` -->

## 可重用内容

### `<include>`

`include`标签用于将另一个模板（或者是另一个模板的一部分）嵌入到当前模板中。

`include`标签可以将模板的路径作为第一个参数：

```marko
<include('./path/to/template.marko')/>
```

第二个参数可用于将输入传递给被包含的模板：

```marko
<include('./path/to/template.marko', { name:'Frank' })/>
```

属性也可以用于将数据传递到包含的模板，并且可以与输入参数组合使用，并且可以与输入参数组合使用：

```marko
<include('./path/to/template.marko', data) name="Frank"/>
```

#### 通过嵌套属性布局

除了包含外部内容，你还可以将附加的内容块（chunks）插入到外部内容中。这是通过使用由`@`符号表示的嵌套属性标签来实现的：

_page.marko_
```marko
<include('./layout.marko')>
    <@body>
        <h1>Hello Marko</h1>
    </@body>
</include>
```

然后，在布局模板中，你可以`include`注入的内容：

_layout.marko_
```marko
<!doctype html>
<html>
    <body>
        <!-- this comes from <@body> -->
        <include(input.body)/>
    </body>
</html>
```

<!--
- You can use many nested attribute tags for multiple injection points
- You can have repeated nested attribute tags by using `marko-tag.json` (components only)
- You can add additional attributes to an nested attribute tag
- You can pass data to a nested attribute tag's body?
-->

### `<include-text>`

```marko
<include-text('./foo.txt')/>
```

特殊的HTML字符将被转义（escaped）。如果你不想被转义，那么可以使用`<include-html>`标签（见下文）。

### `<include-html>`

```marko
<include-html('./foo.html')/>
```

特殊的HTML字符将 _不会_ 被转义，因为该文件预期是一个HTML文件。

### `<macro>`

参数化宏允许定义HTML模板中的可重用片段。
宏可以使用`<macro>`指令定义：

```marko
<macro greeting(name, count)>
    Hello ${name}! You have ${count} new messages.
</macro>
```

上述宏可以作为任何表达式的一部分被调用。下述示例展示了如何在表达式中使用宏函数：

```marko
<macro greeting(name, count)>
    Hello ${name}! You have ${count} new messages.
</macro>
<p>
    <greeting("John", 10)/>
</p>
<p>
    <!-- Or, using named attributes: -->
    <greeting name="Frank" count=20/>
</p>
```

## 异步内容

### `<await>`

 `<await>` 标签用于从数据提供者动态地加载内容。数据源可以一个是`Promise` 或一个`callback`。一旦数据源返回了结果，`<await>`中的内容将被渲染。

await-example.marko
```marko
$ var personPromise = new Promise((resolve, reject) => {
    setTimeout(function() {
        resolve({
            name: 'Frank'
        });
    }, 1000);
});

<await(person from personPromise)>
    <div>Hello ${person.name}!</div>
</await>
```

高级特性:
+ `<await>` 标签
    * 基本用法: `<await(来自数据源的结果)>...</await>`
    * 可选的属性
        - client-reorder `boolean`
        - arg `expression`
        - arg-* `string`
        - method `string`
        - timeout `integer`
        - timeout-message `string`
        - error-message `string`
        - placeholder `string`
        - renderTimeout `function`
        - renderError `function`
        - renderPlaceholder `function`
        - name `string`
        - scope `expression`
        - show-after `string`
    * 可选的子标签
        - `<await-placeholder>加载中</await-placeholder>`
        - `<await-timeout>请求超时</await-timeout>`
        - `<await-error>请求失败</await-error>`

## 注释

可以使用标准的HTML注释向模板中添加注释，HTML注释不会出现在渲染的HTML中。

注释示例:

```marko
<!-- This is a comment that will not be rendered -->
<h1>Hello</h1>
```

```js
// You can also use standard JavaScript-style comments
/*
 Block comments are also supported
 */
-- Hello
```

如果您希望在最终的输出中显示你的HTML注释，那么可以使用自定义的`html-comment`标签。

### `<html-comment>`

_input.marko_
```marko
<html-comment>This is a comment that *will* be rendered</html-comment>
<h1>Hello</h1>
```

_output.html_
```html
<!--This is a comment that *will* be rendered-->
<h1>Hello</h1>
```

除此之外，`<marko-compiler-options>`标签可以用于为整个模板配置注释：

```marko
<marko-compiler-options preserve-comments/>
```

## 编译器选项

### `marko-preserve-whitespace`

可以通过使用`preserve-whitespace`属性来保留空格：

```marko
<div marko-preserve-whitespace>
    All of this
    whitespace   will
    be preserved.
</div>
```
除此之外，`<marko-compiler-options>`标签可用于为整个模板配置空格：

```marko
<marko-compiler-options preserve-whitespace/>
```

### `marko-body`

`marko-body` 属性可用于控制如何解析内容。支持以下值：
- `html` - 正文内容将会被解析HTML（默认值）
- `static-text` - 正文内容将被解析为静态文本（HTML标签将被忽略），占位符将会被忽略。
- `parsed-text` - 文内容将被解析为文本（HTML标签将被忽略），占位符不会被忽略。

_input.marko_
```marko
<div marko-body="static-text">
    This is just one
    <span if(foo)>
            Hello ${THIS IS NOT VALID}!
    </span>
    big text block
</div>
```

_output.html_
```html
<div>
    This is just one
    &lt;span if(foo)&gt;
        Hello ${THIS IS NOT VALID}!
    &lt;/span&gt;
    big text block
</div>
```
